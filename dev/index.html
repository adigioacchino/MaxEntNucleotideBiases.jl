<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MaxEntNucleotideBiases.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://adigioacchino.github.io/MaxEntNucleotideBiases.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>MaxEntNucleotideBiases.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Introduction-and-references"><span>Introduction and references</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/adigioacchino/MaxEntNucleotideBiases.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MaxEntNucleotideBiases"><a class="docs-heading-anchor" href="#MaxEntNucleotideBiases">MaxEntNucleotideBiases</a><a id="MaxEntNucleotideBiases-1"></a><a class="docs-heading-anchor-permalink" href="#MaxEntNucleotideBiases" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/adigioacchino/MaxEntNucleotideBiases.jl">MaxEntNucleotideBiases</a>.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>This package is not registered. Install with:</p><pre><code class="language-julia hljs">import Pkg
Pkg.add(url=&quot;https://github.com/adigioacchino/MaxEntNucleotideBiases.jl&quot;)</code></pre><h2 id="Introduction-and-references"><a class="docs-heading-anchor" href="#Introduction-and-references">Introduction and references</a><a id="Introduction-and-references-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-and-references" title="Permalink"></a></h2><p>TBD</p><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><h3 id="Basic-usage"><a class="docs-heading-anchor" href="#Basic-usage">Basic usage</a><a id="Basic-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-usage" title="Permalink"></a></h3><p>We will take sub-sequence from the Influenza H5N1 PB2 segment (strain used: A/Anhui/1/2005) and we will use it as working example to test the function of the package. We start by loading the package and the sequence:</p><pre><code class="language-julia hljs">using MaxEntNucleotideBiases
example_seq = &quot;ATGGAGAGAATAAAAGAATTAAGGGATCTAATGTCACAGTCCCGCACTCGCGAGATACTAACAAAAACCACTGTGGACCATATGGCCATAATCAAGAAGTACACATCAGGAAGACAAGAGAAGAACCCTGCTCTCAGAATGAAATGGATGATGGCAATGAAATATCCAATCACAGCGGACAAGAGAATAACAGAGATGATTCCTGAAAGGAATGAACAAGGGCAGACGCTCTGGAGCAAGACAAATGATGCCGGATCGGACAGGTTGATGGTGTCTCCCTTAGCTGTAACTTGGTGGAATAGGAATGGGCCGACGACAAGTGCAGTCCATTATCCAAAGGTTTACAAAACATACTTTGAGAAGGCT&quot;</code></pre><p>The package allows to fit up to 1-, 2- or 3-mers (i.e. single nucleotide, dinucleotide or trinucleotide) forces.  To do so, we will use the <code>fitmodel</code> function, whose second argument is the &#39;k&#39; of the maximum k-mers we want to consider (1, 2 or 3).</p><p>We will start by fitting the single nucleotide biases:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; mod1 = MaxEntNucleotideBiases.fitmodel(example_seq, 1)</code><code class="nohighlight hljs ansi" style="display:block;">MaxEntNucleotideBiases.NucleotideModel([&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;T&quot;], [-0.9973585549629368, -1.6541380913520074, -1.3917738268845161, -1.6541380913520074], 1)</code></pre><p>The result is a <code>NucleotideModel</code> object, which contains the motifs, the fitted parameters and the value of &#39;k&#39;. Similarly, we can fit dinucleotide and trinucleotide biases:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; mod2 = MaxEntNucleotideBiases.fitmodel(example_seq, 2)</code><code class="nohighlight hljs ansi" style="display:block;">MaxEntNucleotideBiases.NucleotideModel([&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;AA&quot;, &quot;AC&quot;, &quot;AG&quot;, &quot;CA&quot;, &quot;CC&quot;, &quot;CG&quot;, &quot;GA&quot;, &quot;GC&quot;, &quot;GG&quot;, &quot;T&quot;, &quot;AT&quot;, &quot;CT&quot;, &quot;GT&quot;, &quot;TA&quot;, &quot;TC&quot;, &quot;TG&quot;, &quot;TT&quot;], [0.4781021466335377, -0.19372982399851668, -0.03740292491035202, -0.0707982850229234, -0.13444056404906718, -0.0322597908019277, 0.20043479066516756, 0.11573904849216937, -0.5805713590519683, 0.2797124991606199, -0.18635024640478087, 0.167144462632211, -0.24696939772466892, 0.23749863987391823, 0.2643975198946316, -0.26050671538805004, -0.40934900480286396, 0.20505176196167868, 0.4456866872216851, -0.24138944438049975], 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mod3 = MaxEntNucleotideBiases.fitmodel(example_seq, 3)</code><code class="nohighlight hljs ansi" style="display:block;">MaxEntNucleotideBiases.NucleotideModel([&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;AA&quot;, &quot;AC&quot;, &quot;AG&quot;, &quot;CA&quot;, &quot;CC&quot;, &quot;CG&quot;, &quot;GA&quot;  …  &quot;TCG&quot;, &quot;TCT&quot;, &quot;TGA&quot;, &quot;TGC&quot;, &quot;TGG&quot;, &quot;TGT&quot;, &quot;TTA&quot;, &quot;TTC&quot;, &quot;TTG&quot;, &quot;TTT&quot;], [0.5729006690181976, -0.1792117252504917, -0.09335499840626785, -0.018679350876443332, -0.30028156934096595, 0.009220062196747092, 0.23222804674887165, 0.23384965485088682, -1.086778896880923, 0.3556848971534008  …  -0.12422784442288964, -0.03620508197438563, -0.43401803460091637, -0.6059559079122996, 0.17224822191488132, 0.8677257205983349, 0.7345194713051757, -0.8888712743566658, -0.18836388296469292, 0.3427156860161829], 3)</code></pre><p>From a model we can obtain a dictionary (motif =&gt; force) with the <code>get_forces_dict</code> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; MaxEntNucleotideBiases.get_forces_dict(mod2)</code><code class="nohighlight hljs ansi" style="display:block;">Dict{String, Float64} with 20 entries:
  &quot;AT&quot; =&gt; 0.237499
  &quot;A&quot;  =&gt; 0.478102
  &quot;CA&quot; =&gt; 0.200435
  &quot;C&quot;  =&gt; -0.19373
  &quot;T&quot;  =&gt; -0.246969
  &quot;TG&quot; =&gt; 0.445687
  &quot;CC&quot; =&gt; 0.115739
  &quot;G&quot;  =&gt; -0.0374029
  &quot;GT&quot; =&gt; -0.260507
  &quot;TA&quot; =&gt; -0.409349
  &quot;GA&quot; =&gt; 0.279712
  &quot;TT&quot; =&gt; -0.241389
  &quot;AC&quot; =&gt; -0.134441
  &quot;CT&quot; =&gt; 0.264398
  &quot;GC&quot; =&gt; -0.18635
  &quot;AA&quot; =&gt; -0.0707983
  &quot;AG&quot; =&gt; -0.0322598
  &quot;GG&quot; =&gt; 0.167144
  &quot;CG&quot; =&gt; -0.580571
  &quot;TC&quot; =&gt; 0.205052</code></pre><p>Finally, we can compute several interesting quantities:</p><ul><li>the energy of any sequence with a given model, with the <code>compute_minus_energy</code> function:</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; L = 1000;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; seq = join(rand([&quot;A&quot;,&quot;C&quot;,&quot;G&quot;,&quot;T&quot;], L));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; MaxEntNucleotideBiases.compute_minus_energy(mod3, seq)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching compute_minus_energy(::MaxEntNucleotideBiases.NucleotideModel, ::String)</code></pre><ul><li>the log-likelihood of any sequence with a given model, with the <code>compute_loglikelihood</code> function:</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; L = 1000;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; seq = join(rand([&quot;A&quot;,&quot;C&quot;,&quot;G&quot;,&quot;T&quot;], L));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; MaxEntNucleotideBiases.compute_loglikelihood(mod2, seq)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching compute_loglikelihood(::MaxEntNucleotideBiases.NucleotideModel, ::String)</code></pre><h3 id="Gauge-choices"><a class="docs-heading-anchor" href="#Gauge-choices">Gauge choices</a><a id="Gauge-choices-1"></a><a class="docs-heading-anchor-permalink" href="#Gauge-choices" title="Permalink"></a></h3><p>There are several gauge choices that can be used to fit the model. The default choice is the &#39;zero-sum&#39; gauge, that is described in the paper. The other notable choice is the &#39;lattice gas gauge&#39;, which is again described in the paper and is implemented in this package. In particular, the results of the inference can be directly returned in the lattice gas gauge with the <code>ZS_gauge</code> argument passed as <code>false</code> to the <code>fitmodel</code> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; mod2 = MaxEntNucleotideBiases.fitmodel(example_seq, 2, ZS_gauge=false)</code><code class="nohighlight hljs ansi" style="display:block;">MaxEntNucleotideBiases.NucleotideModel([&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;AA&quot;, &quot;AC&quot;, &quot;AG&quot;, &quot;CA&quot;, &quot;CC&quot;, &quot;CG&quot;, &quot;GA&quot;, &quot;GC&quot;, &quot;GG&quot;, &quot;T&quot;, &quot;AT&quot;, &quot;CT&quot;, &quot;GT&quot;, &quot;TA&quot;, &quot;TC&quot;, &quot;TG&quot;, &quot;TT&quot;], [1.0360000681902604, 1.005467744343462, 0.8775253334089516, -0.14033736447447745, -0.8183804102651638, -0.9568345622780308, 0.10399683119290017, -0.5950996777446407, -1.5320450105487848, 0.7081787749710342, -0.3722847373589092, -0.25942495358192375, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 2)</code></pre><p>Moreover, the zero-sum gauge can be restored after the inference with the <code>gauge_zerosum</code> function:</p><pre><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; MaxEntNucleotideBiases.gauge_zerosum(mod2)</code><code class="nohighlight hljs ansi" style="display:block;">MaxEntNucleotideBiases.NucleotideModel([&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;AA&quot;, &quot;AC&quot;, &quot;AG&quot;, &quot;CA&quot;, &quot;CC&quot;, &quot;CG&quot;, &quot;GA&quot;, &quot;GC&quot;, &quot;GG&quot;, &quot;T&quot;, &quot;AT&quot;, &quot;CT&quot;, &quot;GT&quot;, &quot;TA&quot;, &quot;TC&quot;, &quot;TG&quot;, &quot;TT&quot;], [0.4781021466335377, -0.19372982399851668, -0.03740292491035202, -0.0707982850229234, -0.13444056404906718, -0.0322597908019277, 0.20043479066516756, 0.11573904849216937, -0.5805713590519683, 0.2797124991606199, -0.18635024640478087, 0.167144462632211, -0.24696939772466892, 0.23749863987391823, 0.2643975198946316, -0.26050671538805004, -0.40934900480286396, 0.20505176196167868, 0.4456866872216851, -0.24138944438049975], 2)</code></pre><h3 id="Entropy-and-related-quantities"><a class="docs-heading-anchor" href="#Entropy-and-related-quantities">Entropy and related quantities</a><a id="Entropy-and-related-quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Entropy-and-related-quantities" title="Permalink"></a></h3><p>The simple structure of the models fitted with this package allows to compute exactly several quantities of interest that, in most other cases, require (uncontrolled) approximations. The first example is the entropy of the probability distribution defined with the model.  It can be computed with the <code>compute_entropy</code> function, and since this quantity depends on the length of the sequences considered, a reference length must be passed as argument:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; L = 1000;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; MaxEntNucleotideBiases.compute_entropy(L, mod3)</code><code class="nohighlight hljs ansi" style="display:block;">1274.7421600865414</code></pre><p>The entropy of the model can be used to quantify how different the probability distribution defined by the model is from the uniform distribution, which in turn is a measure of the &#39;pressure&#39; that is exerted on the nucleotides to be used in a certain way. In this package, the pressure ranges from 0 (unconstrained model) to 1 (fully constrained model), and it is computed with the <code>compute_pressure</code> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; L = 1000;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; MaxEntNucleotideBiases.compute_pressure(L, mod3)</code><code class="nohighlight hljs ansi" style="display:block;">0.08046790361553069</code></pre><p>Finally, it can be interesting to quantify how much two models are different from each other.  This package address this problem with the <code>compute_symmetrized_kl</code> function, which computes the symmetrized Kullback-Leibler divergence between two models:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; L = 1000;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mod3_unif = MaxEntNucleotideBiases.fitmodel(join(rand([&quot;A&quot;,&quot;C&quot;,&quot;G&quot;,&quot;T&quot;], L)), 3)</code><code class="nohighlight hljs ansi" style="display:block;">MaxEntNucleotideBiases.NucleotideModel([&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;AA&quot;, &quot;AC&quot;, &quot;AG&quot;, &quot;CA&quot;, &quot;CC&quot;, &quot;CG&quot;, &quot;GA&quot;  …  &quot;TCG&quot;, &quot;TCT&quot;, &quot;TGA&quot;, &quot;TGC&quot;, &quot;TGG&quot;, &quot;TGT&quot;, &quot;TTA&quot;, &quot;TTC&quot;, &quot;TTG&quot;, &quot;TTT&quot;], [-0.00902035851683372, 0.0014059311359382598, -0.09769092634858914, -0.09144934515972036, 0.17726637163502068, -0.0018457840262398606, 0.04098752039361003, -0.15331138345977907, 0.1102785067407397, 0.12657156501073807  …  -0.25481873668948213, 0.03646937573141046, -0.04848335082228518, -0.3264349728200681, 0.28949975408026607, 0.08541856956208722, 0.40800094056644326, -0.4198956527075129, -0.01040150432819005, 0.022296216469259673], 3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; MaxEntNucleotideBiases.compute_symmetrized_kl(L, mod3, mod3_unif)</code><code class="nohighlight hljs ansi" style="display:block;">136.3668699204818</code></pre><h3 id="Sampling"><a class="docs-heading-anchor" href="#Sampling">Sampling</a><a id="Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling" title="Permalink"></a></h3><p>Another interseting feature of this package is the possibility to sample sequences from an inferred model. This package implements a simple Metropolis routine to sample sequences from a model:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; L = 1000;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; MaxEntNucleotideBiases.sample_metropolis(L, mod3,
                                                Nsamples=10, Nsteps=3000, Ntherm=10_000, beta=1.)</code><code class="nohighlight hljs ansi" style="display:block;">10-element Vector{String}:
 &quot;AAATCGAATCGGCTGTAAGCCACTTGTGTTA&quot; ⋯ 939 bytes ⋯ &quot;GAAGATGGGCGCCCTCTGGAACAACTTACA&quot;
 &quot;GCTTGGAGCTCCCTTCTCACTTTTGTCAAGT&quot; ⋯ 939 bytes ⋯ &quot;GCAAACTGGGTCACCAAGGTGGGTAAGACA&quot;
 &quot;CTGTAACATTGGATGTGGGCTTAAGACCTGC&quot; ⋯ 939 bytes ⋯ &quot;AATGAGAAGCAATAAAAGGAGAAAAATTAT&quot;
 &quot;AAACTAATGTGGCCATGGCCCTTAATCAGGC&quot; ⋯ 939 bytes ⋯ &quot;ACAGGTTAGAGATAAATTAAGCCGCATTAA&quot;
 &quot;GAAATGAGCTCAAGAACAATCGGAAACAGGT&quot; ⋯ 939 bytes ⋯ &quot;GTCACCCGACAAGAATATATGGAGAAGGAA&quot;
 &quot;AGGCAGGAGTGGAAAGCCAATGCTGGCAAGA&quot; ⋯ 939 bytes ⋯ &quot;ATGGTCTCAACCGAAGGCATGGACATGTAT&quot;
 &quot;CTGGCGGAGTGCTGGTGCTGAATTCAGAATC&quot; ⋯ 939 bytes ⋯ &quot;CAAAGATAAAGATGGAGGTGGGCGAGTCAC&quot;
 &quot;CAGCAGACACATGTCCAGACAAGAACTACTT&quot; ⋯ 939 bytes ⋯ &quot;GCTATGAATACAGAGGAATAACAACAGAAG&quot;
 &quot;GTCCAAGGACGGTTGAGAATGAAGTCAAACA&quot; ⋯ 939 bytes ⋯ &quot;CACATGGGAGGGTTAAACACACACATCACT&quot;
 &quot;CCTCTGGTCCGCGAATAAACAATGACATGAT&quot; ⋯ 939 bytes ⋯ &quot;CAGATAATGACAATACTCCCCTGGATCAGA&quot;</code></pre><h3 id="Model-I/O"><a class="docs-heading-anchor" href="#Model-I/O">Model I/O</a><a id="Model-I/O-1"></a><a class="docs-heading-anchor-permalink" href="#Model-I/O" title="Permalink"></a></h3><p>The model inference can take some time, so it can be useful to save the model on disk and load it later. This can be done with the <code>save_model</code> and <code>load_model</code> functions:</p><pre><code class="language-julia hljs">MaxEntNucleotideBiases.writemodel(mod3, &quot;mod3.menb&quot;)
mod3 = MaxEntNucleotideBiases.readmodel(&quot;mod3.menb&quot;)</code></pre><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><ul><li><a href="#MaxEntNucleotideBiases._compute_nobs-Tuple{Vector{String}, Vector{String}, Int64}"><code>MaxEntNucleotideBiases._compute_nobs</code></a></li><li><a href="#MaxEntNucleotideBiases._mcstep!-Tuple{Int64, Int64, Vector{String}, MaxEntNucleotideBiases.NucleotideModel, Float64}"><code>MaxEntNucleotideBiases._mcstep!</code></a></li><li><a href="#MaxEntNucleotideBiases._preprocess_seqs-Tuple{Vector{String}}"><code>MaxEntNucleotideBiases._preprocess_seqs</code></a></li><li><a href="#MaxEntNucleotideBiases.compute_entropy-Tuple{Int64, MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.compute_entropy</code></a></li><li><a href="#MaxEntNucleotideBiases.compute_loglikelihood-Tuple{String, MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.compute_loglikelihood</code></a></li><li><a href="#MaxEntNucleotideBiases.compute_logz-Tuple{MaxEntNucleotideBiases.NucleotideModel, Int64}"><code>MaxEntNucleotideBiases.compute_logz</code></a></li><li><a href="#MaxEntNucleotideBiases.compute_logz_fast-Tuple{MaxEntNucleotideBiases.NucleotideModel, Int64}"><code>MaxEntNucleotideBiases.compute_logz_fast</code></a></li><li><a href="#MaxEntNucleotideBiases.compute_minus_energy-Tuple{AbstractString, MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.compute_minus_energy</code></a></li><li><a href="#MaxEntNucleotideBiases.compute_pressure-Tuple{Int64, MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.compute_pressure</code></a></li><li><a href="#MaxEntNucleotideBiases.compute_symmetrized_kl-Tuple{Int64, MaxEntNucleotideBiases.NucleotideModel, MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.compute_symmetrized_kl</code></a></li><li><a href="#MaxEntNucleotideBiases.fitmodel"><code>MaxEntNucleotideBiases.fitmodel</code></a></li><li><a href="#MaxEntNucleotideBiases.gauge_mask_variables-Tuple{Vector{String}}"><code>MaxEntNucleotideBiases.gauge_mask_variables</code></a></li><li><a href="#MaxEntNucleotideBiases.gauge_zerosum-Tuple{MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.gauge_zerosum</code></a></li><li><a href="#MaxEntNucleotideBiases.generate_transfer_matrix-Tuple{MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.generate_transfer_matrix</code></a></li><li><a href="#MaxEntNucleotideBiases.generate_transfer_matrix_last-Tuple{MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.generate_transfer_matrix_last</code></a></li><li><a href="#MaxEntNucleotideBiases.get_forces_dict-Tuple{MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.get_forces_dict</code></a></li><li><a href="#MaxEntNucleotideBiases.readmodel-Tuple{AbstractString}"><code>MaxEntNucleotideBiases.readmodel</code></a></li><li><a href="#MaxEntNucleotideBiases.sample_metropolis-Tuple{Int64, MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.sample_metropolis</code></a></li><li><a href="#MaxEntNucleotideBiases.writemodel-Tuple{AbstractString, MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.writemodel</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="MaxEntNucleotideBiases._compute_nobs-Tuple{Vector{String}, Vector{String}, Int64}" href="#MaxEntNucleotideBiases._compute_nobs-Tuple{Vector{String}, Vector{String}, Int64}"><code>MaxEntNucleotideBiases._compute_nobs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_compute_nobs(seqs::Vector{String}, independent_motifs::Vector{String}, L::Int)</code></pre><p>For each motif in <code>independent_motifs</code>, compute the number of observed motifs in each sequence in <code>seqs</code>, then divide by the sequence length, take the average of these intensive fractions over the sequences, and multiply by the model length L.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adigioacchino/MaxEntNucleotideBiases.jl/blob/fb0d8de11a5ca4294aa364f5f22c3279b3c1ba46/src/MENB_InferModel.jl#L20-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntNucleotideBiases._mcstep!-Tuple{Int64, Int64, Vector{String}, MaxEntNucleotideBiases.NucleotideModel, Float64}" href="#MaxEntNucleotideBiases._mcstep!-Tuple{Int64, Int64, Vector{String}, MaxEntNucleotideBiases.NucleotideModel, Float64}"><code>MaxEntNucleotideBiases._mcstep!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_mcstep!(L::Int, mlk::Int, curr_seq::Vector{String}, 
              model::NucleotideModel, 
              beta::Float64)</code></pre><p>Performs a MonteCarlo step; L is curr<em>seq length, mlk is the maximum length of the motifs considered, curr</em>seq is the starting sequence, model specifies the model,  and beta is the inverse temperature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adigioacchino/MaxEntNucleotideBiases.jl/blob/fb0d8de11a5ca4294aa364f5f22c3279b3c1ba46/src/MENB_Utils.jl#L51-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntNucleotideBiases._preprocess_seqs-Tuple{Vector{String}}" href="#MaxEntNucleotideBiases._preprocess_seqs-Tuple{Vector{String}}"><code>MaxEntNucleotideBiases._preprocess_seqs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_preprocess_seqs(seqs_in::Vector{String})</code></pre><p>Pre-process the vector of sequences <code>seqs_in</code>, so that sequences only contains letters A, C, G, T. The pre-processed sequence vector is the returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adigioacchino/MaxEntNucleotideBiases.jl/blob/fb0d8de11a5ca4294aa364f5f22c3279b3c1ba46/src/MENB_InferModel.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntNucleotideBiases.compute_entropy-Tuple{Int64, MaxEntNucleotideBiases.NucleotideModel}" href="#MaxEntNucleotideBiases.compute_entropy-Tuple{Int64, MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.compute_entropy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_entropy(L::Int, model::NucleotideModel; fast::Bool=false)</code></pre><p>Compute the entropy of the model with parameters <code>model_pars</code> and having length <code>L</code>. The computation exploit the derivatives of the partition function, that can be approximated to make it faster (using <code>fast=true</code>), although it should be very quick in any case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adigioacchino/MaxEntNucleotideBiases.jl/blob/fb0d8de11a5ca4294aa364f5f22c3279b3c1ba46/src/MENB_Utils.jl#L120-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntNucleotideBiases.compute_loglikelihood-Tuple{String, MaxEntNucleotideBiases.NucleotideModel}" href="#MaxEntNucleotideBiases.compute_loglikelihood-Tuple{String, MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.compute_loglikelihood</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_loglikelihood(seq::String, model::NucleotideModel; logZ=missing)</code></pre><p>Given a sequence <code>seq</code> and the model parameters <code>model_pars</code>, compute the log-likelihood (energy minus log of Z) of this sequence. logZ can be passed directly if pre-computed, otherwise is it computed each time this function is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adigioacchino/MaxEntNucleotideBiases.jl/blob/fb0d8de11a5ca4294aa364f5f22c3279b3c1ba46/src/MENB_Utils.jl#L28-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntNucleotideBiases.compute_logz-Tuple{MaxEntNucleotideBiases.NucleotideModel, Int64}" href="#MaxEntNucleotideBiases.compute_logz-Tuple{MaxEntNucleotideBiases.NucleotideModel, Int64}"><code>MaxEntNucleotideBiases.compute_logz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_logz(model::NucleotideModel, L::Int)</code></pre><p>Compute the partition function of a model of length L through the transfer matrix method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adigioacchino/MaxEntNucleotideBiases.jl/blob/fb0d8de11a5ca4294aa364f5f22c3279b3c1ba46/src/MENB_PartitionFunction.jl#L86-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntNucleotideBiases.compute_logz_fast-Tuple{MaxEntNucleotideBiases.NucleotideModel, Int64}" href="#MaxEntNucleotideBiases.compute_logz_fast-Tuple{MaxEntNucleotideBiases.NucleotideModel, Int64}"><code>MaxEntNucleotideBiases.compute_logz_fast</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_logz_fast(model::NucleotideModel, L::Int)</code></pre><p>Compute the partition function of a model of length L by taking the real part of the largest eigenvalue of the transfer matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adigioacchino/MaxEntNucleotideBiases.jl/blob/fb0d8de11a5ca4294aa364f5f22c3279b3c1ba46/src/MENB_PartitionFunction.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntNucleotideBiases.compute_minus_energy-Tuple{AbstractString, MaxEntNucleotideBiases.NucleotideModel}" href="#MaxEntNucleotideBiases.compute_minus_energy-Tuple{AbstractString, MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.compute_minus_energy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_minus_energy(seq::String, model::NucleotideModel)</code></pre><p>Given a sequence <code>seq</code> and the model parameters <code>model_pars</code>,  compute (minus) the energy of this sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adigioacchino/MaxEntNucleotideBiases.jl/blob/fb0d8de11a5ca4294aa364f5f22c3279b3c1ba46/src/MENB_Utils.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntNucleotideBiases.compute_pressure-Tuple{Int64, MaxEntNucleotideBiases.NucleotideModel}" href="#MaxEntNucleotideBiases.compute_pressure-Tuple{Int64, MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.compute_pressure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_pressure(L::Int, model::NucleotideModel; fast::Bool=false)</code></pre><p>The pressure on a genome can be quantified as how the genome is different from a random uniform one. Therefore, this function compute the difference in the entropy of a random uniform model and the model described with <code>model_pars</code>, with lenght <code>L</code>, rescaled with the entropy of the uniform model. Setting <code>fast=true</code> allows for a quicker estimation of the entropy of the model (it can be useful for extremely large sequences).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adigioacchino/MaxEntNucleotideBiases.jl/blob/fb0d8de11a5ca4294aa364f5f22c3279b3c1ba46/src/MENB_Utils.jl#L146-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntNucleotideBiases.compute_symmetrized_kl-Tuple{Int64, MaxEntNucleotideBiases.NucleotideModel, MaxEntNucleotideBiases.NucleotideModel}" href="#MaxEntNucleotideBiases.compute_symmetrized_kl-Tuple{Int64, MaxEntNucleotideBiases.NucleotideModel, MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.compute_symmetrized_kl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_symmetrized_kl(L::Int, model1::NucleotideModel, 
                    model2::NucleotideModel; fast::Bool=false)</code></pre><p>Compute the symmetrized version of the Kullback-Leibler divergence between the distributions defined by <code>model1_pars</code> and <code>model2_pars</code>. Setting <code>fast=true</code> allows for a quicker estimation  of the KL divergence (it can be useful for extremely large sequences).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adigioacchino/MaxEntNucleotideBiases.jl/blob/fb0d8de11a5ca4294aa364f5f22c3279b3c1ba46/src/MENB_Utils.jl#L160-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntNucleotideBiases.fitmodel" href="#MaxEntNucleotideBiases.fitmodel"><code>MaxEntNucleotideBiases.fitmodel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fitmodel(seqs::Union{Vector{String}, String}, Lmotifs::Int, Lmodel::Union{Int,Missing}=missing; 
              pseudocount_param::Float64=0.0, tolerance::Float64=0.01, max_iter::Int=100, 
              verbose::Bool=false, fast::Union{Bool,String}=&quot;auto&quot;, ZS_gauge::Bool=true)</code></pre><p>Fit the model parameters, which are:</p><ul><li>only 1-point functions (fields) if Lmotifs==1;</li><li>1-point and 2-point functions (fields, 2-mer forces) if Lmotifs==2;</li><li>1-point, 2-point and 3-point functions (fields, 2-mer and 3-mer forces) if Lmotifs==3.</li></ul><p><code>Lmodel</code> is the number of nucleotides used for the inference. If <code>seqs</code> is made of  sequences of constant length (or if it is String and not a vector), the default option will use the sequences length as <code>Lmodel</code>; otherwise, the default behaviour is to take <code>Lmodel</code> = 5000.</p><p><code>pseudocount_param</code> is the fraction of weigth coming from random uniform sequences in the computation of the motif&#39;s frequences from the data.</p><p>If <code>fast</code>, the partition function is estimated through the top eigenvalue of the transfer matrix alone (much faster, but slightly less precise, expecially for short sequences). The default value, &quot;auto&quot;, automatically uses the fast  evaluation for long sequences.</p><p><code>tolerance</code> and <code>max_iter</code> are parameters for the Newton-Raphson algorithm  used to solve the system of equations.</p><p><code>ZS_gauge</code> specifies whether the result has to be put in the zero sum gauge before being returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adigioacchino/MaxEntNucleotideBiases.jl/blob/fb0d8de11a5ca4294aa364f5f22c3279b3c1ba46/src/MENB_InferModel.jl#L33-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntNucleotideBiases.gauge_mask_variables-Tuple{Vector{String}}" href="#MaxEntNucleotideBiases.gauge_mask_variables-Tuple{Vector{String}}"><code>MaxEntNucleotideBiases.gauge_mask_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gauge_mask_variables(motifs::Vector{String})</code></pre><p>This function returns a Array{Bool} corresponding to motifs that have to be inferred after all motifs containing Ts are fixed to 0 thanks to gauge transformations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adigioacchino/MaxEntNucleotideBiases.jl/blob/fb0d8de11a5ca4294aa364f5f22c3279b3c1ba46/src/MENB_Gauge.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntNucleotideBiases.gauge_zerosum-Tuple{MaxEntNucleotideBiases.NucleotideModel}" href="#MaxEntNucleotideBiases.gauge_zerosum-Tuple{MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.gauge_zerosum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gauge_zerosum(model_pars::NucleotideModel)</code></pre><p>This function takes as input a dictionary describing the parmeters of a model and changes the gauge into the &quot;zero-sum&quot; gauge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adigioacchino/MaxEntNucleotideBiases.jl/blob/fb0d8de11a5ca4294aa364f5f22c3279b3c1ba46/src/MENB_Gauge.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntNucleotideBiases.generate_transfer_matrix-Tuple{MaxEntNucleotideBiases.NucleotideModel}" href="#MaxEntNucleotideBiases.generate_transfer_matrix-Tuple{MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.generate_transfer_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_transfer_matrix(model::NucleotideModel)</code></pre><p>Return the trasfer matrix used for the computation of the partition function. The first index correspond to the left-most nucleotide, the last index to the right-most one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adigioacchino/MaxEntNucleotideBiases.jl/blob/fb0d8de11a5ca4294aa364f5f22c3279b3c1ba46/src/MENB_PartitionFunction.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntNucleotideBiases.generate_transfer_matrix_last-Tuple{MaxEntNucleotideBiases.NucleotideModel}" href="#MaxEntNucleotideBiases.generate_transfer_matrix_last-Tuple{MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.generate_transfer_matrix_last</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_transfer_matrix_last(model::NucleotideModel)</code></pre><p>Return the last transfer matrix used for the computation of the partition function. The first index correspond to the left-most nucleotide, the last index to the right-most one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adigioacchino/MaxEntNucleotideBiases.jl/blob/fb0d8de11a5ca4294aa364f5f22c3279b3c1ba46/src/MENB_PartitionFunction.jl#L41-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntNucleotideBiases.get_forces_dict-Tuple{MaxEntNucleotideBiases.NucleotideModel}" href="#MaxEntNucleotideBiases.get_forces_dict-Tuple{MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.get_forces_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_forces_dict(model::NucleotideModel)</code></pre><p>Return a dictionary of the form motif =&gt; force.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adigioacchino/MaxEntNucleotideBiases.jl/blob/fb0d8de11a5ca4294aa364f5f22c3279b3c1ba46/src/MaxEntNucleotideBiases.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntNucleotideBiases.readmodel-Tuple{AbstractString}" href="#MaxEntNucleotideBiases.readmodel-Tuple{AbstractString}"><code>MaxEntNucleotideBiases.readmodel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readmodel(fname::AbstractString)</code></pre><p>Read <code>file</code> (that should have been written by <code>writemodel</code>)  to get a NucleotideModel, which is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adigioacchino/MaxEntNucleotideBiases.jl/blob/fb0d8de11a5ca4294aa364f5f22c3279b3c1ba46/src/MaxEntNucleotideBiases.jl#L49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntNucleotideBiases.sample_metropolis-Tuple{Int64, MaxEntNucleotideBiases.NucleotideModel}" href="#MaxEntNucleotideBiases.sample_metropolis-Tuple{Int64, MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.sample_metropolis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_metropolis(L::Int, model::NucleotideModel; 
                         beta::Float64=1.0, Nsamples::Int=1, Nsteps::Int=1, Ntherm::Int=L*10, 
                         startseq::Union{String,Missing}=missing)</code></pre><p>Sample Nsample sequences of length L at inverse temperature beta using a model given in model.  Ntherm is the number of MonteCarlo steps done before starting collecting sequences,  startseq is the starting sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adigioacchino/MaxEntNucleotideBiases.jl/blob/fb0d8de11a5ca4294aa364f5f22c3279b3c1ba46/src/MENB_Utils.jl#L82-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MaxEntNucleotideBiases.writemodel-Tuple{AbstractString, MaxEntNucleotideBiases.NucleotideModel}" href="#MaxEntNucleotideBiases.writemodel-Tuple{AbstractString, MaxEntNucleotideBiases.NucleotideModel}"><code>MaxEntNucleotideBiases.writemodel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">writemodel(fname::AbstractString, model::NucleotideModel)</code></pre><p>Write <code>model</code> to <code>fname</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adigioacchino/MaxEntNucleotideBiases.jl/blob/fb0d8de11a5ca4294aa364f5f22c3279b3c1ba46/src/MaxEntNucleotideBiases.jl#L32-L36">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 12 August 2023 09:53">Saturday 12 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
